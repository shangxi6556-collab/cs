// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract RedEnvelopePoolBNB is ReentrancyGuard, Ownable {
    IERC20 public immutable token;                    // 你的代币合约地址（部署时填）
    uint256 public currentRound;
    uint256 public roundStartTime;
    uint256 public remainingAmount;
    uint256 public remainingSlots;

    uint256 public constant MIN_HOLD = 10_000 * 1e18;   // 必须持有 10000 枚
    uint256 public constant MAX_WINNERS = 100;
    uint256 public constant DURATION = 1 hours;

    address[] public winnersThisRound;
    mapping(address => bool) public hasClaimed;

    event NewRound(uint256 round, uint256 bnb, uint256 slots);
    event Claimed(address indexed user, uint256 amount);

    constructor(address _token) {
        token = IERC20(_token);
        _transferOwnership(msg.sender);
    }

    receive() external payable {}

    // 机器人每小时调用一次（带本轮中奖名单）
    function startNewRound(address[] calldata winners) external onlyOwner {
        require(block.timestamp >= roundStartTime + DURATION || currentRound == 0);
        require(winners.length <= MAX_WINNERS && winners.length > 0);

        remainingAmount = address(this).balance;
        currentRound++;
        roundStartTime = block.timestamp;
        remainingSlots = winners.length;

        winnersThisRound = winners;
        delete hasClaimed;

        emit NewRound(currentRound, remainingAmount, remainingSlots);
    }

    // 用户网页手动抢（先抢先得 + 持币检测）
    function claim() external nonReentrant {
        require(block.timestamp < roundStartTime + DURATION, "Round ended");
        require(remainingSlots > 0, "No slots");
        require(!hasClaimed[msg.sender], "Already claimed");
        require(token.balanceOf(msg.sender) >= MIN_HOLD, "Hold >= 10,000 tokens");

        // 必须在机器人名单里
        bool isWinner = false;
        for (uint i = 0; i < winnersThisRound.length; i++) {
            if (winnersThisRound[i] == msg.sender) {
                isWinner = true;
                break;
            }
        }
        require(isWinner, "Not in winner list");

        hasClaimed[msg.sender] = true;
        remainingSlots--;

        // 随机金额 0.02~8 BNB
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, currentRound)));
        uint256 amount = 0.02 ether + (seed % 798) * 0.01 ether;
        if (amount > remainingAmount) amount = remainingAmount;

        remainingAmount -= amount;
        payable(msg.sender).transfer(amount);

        emit Claimed(msg.sender, amount);
    }

    // 测试用
    function forceStart(address[] calldata w) external onlyOwner { startNewRound(w); }
    function withdraw() external onlyOwner { payable(owner()).transfer(address(this).balance); }
}
